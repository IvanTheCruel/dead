<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<link href="index.css" rel="stylesheet" type="text/css">
</head>
<body>
	<div class="main">
		<h1>Ход выполнения работы</h1>
		
		<p>а) Построим асинхронный RS триггер на элементах "ИЛИ-НЕ."</p>
		<p>Для этого соберем на рабочем программы столе следующую схему:</p>
		
		<img src="images/rs_ili_ne_scheme.png">
		<p>Теперь приведем схему в действие и проверим ее соответсвие таблице истинности, приведенной во введении:</p>
		<p>Так, если начать с положительного сигнала на выходе Q: </p>
		<img src="images/rs_ili_ne_scheme_1.png">
		<p>Для получение нуля на этом выходе переведем в положение единицы вход R:</p>
		<img src="images/rs_ili_ne_scheme_2.png">
		<p>После исчезновения сигнала на входе R, триггер, как и должен, сохраняет предыдущий сигнал на выходе:</p>
		<img src="images/rs_ili_ne_scheme_3.png">
		<p>Аналогичное поведение в виде смены сигнала и его сохранения наблюдаем для входа S:</p>
		<img src="images/rs_ili_ne_scheme_4.png">
		<p>Из чего может сделать вывод, что триггер полностью соответсвует своей ранее приведенной таблице истинности.</p>

		<p>б) Построим синхронный RS триггер на элементах "И-НЕ."</p>
		<p>Для этого соберем на рабочем столе следующую схему:</p>
		<img src="images/sync_rs_scheme.png">
		<p>Как видим эта схема отличается от асинхронного триггера, как количеством элементов, так и количеством
			входов. Это объясняется наличием синхронизирующего входа С, реализованного посредством двух дополнительных 
			элементов "И-НЕ". Лишь при наличии сигнала на синхранизационном входе состояние триггера
		можно изменить.</p>
		<p>Проверим работоспособность данной схемы при разных значениях входных сигналов.</p>
		<p>Как видно состояние триггера невозможно изменить при отсутсвующем синхросигнале С:</p>
		<img src="images/sync_rs_scheme_1.png">
		<p>Тогда как при его наличии данный триггер работает аналогично асинхронному:</p>
		<img src="images/sync_rs_scheme_2.png">
		<br>
		<img src="images/sync_rs_scheme_3.png">
		<p>Из проделанных опытов делаем вывод, что триггер работает исправно.</p>
		<p>в) Построим асинхронный RS триггер на микросхеме JK.</p>
		<p>Для этого воспользуемся встроенной в TINA схемой JK триггера:</p>
		<img src="images/jk_scheme.png">
		<p>Как видно из представленной модели, в отличие от своей схемы во введении JK триггер в программе TINA имеет 
			на два входа больше. Это объсяняется налием входов !P и !С, которые пожно расшивровать, как "preset" и "clear".
			При подаче на них инвертированного сигнала они ведут себя как входы S и R соответсвенно на асинхронном RS триггере.
			В плане самого JK триггера стоит отметить, что вышеупомянутые входы не учитывают синхросигнал, а также при отсутсвии 
			сигнала блокируют работу входов J и K. Сами же входы J и K, при наличии сигнала на !P и !С работают соответсвенно таблице истинности приведенной во введении, с тем лишь отличием, что они меняют состояние триггера только при спаде синхросигнала, то есть при измении значения сигнала на синхровходе с 1 на 0.</p>
		<p>Исходя из вышеописанного построим слежующую схему, для реализации асинхронного RS триггера на микросхеме JK:</p>
		<img src="images/rs_jk.png">
		<p>Как видим, он полностью соответсвует своей таблице истинности:</p>
		<img src="images/rs_jk_1.png">
		<br>
		<img src="images/rs_jk_2.png">
		<p>Из чего делаем вывод, что триггер построен верно.</p>
	</div>
</body>
</html>